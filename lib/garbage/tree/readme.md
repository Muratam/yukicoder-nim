# 動的木
#   赤黒木 : 基本.最悪でもO(logN)
#   AVL木 : 平衡. 構築が遅い分探索が速い
#   スプレー木 : キャッシュ. 最近アクセスした要素に関して速い.
#   Treap : 乱択. 実装が軽い
#   RBST : ↑ の priorityが不要版

# 困難こんなんだわ
Nim の GC が遅いせいで,std::mapの方がよい.
ref object を動的にむっちゃ作る場合とても悲しい...
1e6 に 213ms 以上掛けたら負け
とりあえず全て配列に確保してやっていくしかない
謎木はtableを作るので無理.
# 他のはなぜ大丈夫か
「1e6 くらいの量のデータを扱う かつ new ref object がネックになる」という問題設定になることがないから.
グラフで1e6も辺があることはまずないし、他の場合はseq[int] が使えるので問題ない。
動的に木を作るのがつらいんだなあ

# 2進パトリシア木
std::map よりも5~10倍遅い
全部 seq に変えても遅いので本質的に遅い...もう探索が遅くてどうしようもない.
かといって trie 木に変えたらさらに6倍遅い.



# 定数倍改善のヒント
- 通常は `tuple[x,y:int]` などのように書いて楽をするが、 定数倍でTLEする場合は `ref object` を検討する価値がある.
-`lib/garbage/timecost` に基づく結果.
  - malloc は動的に行うと10~100倍遅い.可能なら最初に一括でやりたい
  - データはなるべくassignしない.
  - 配列にあるならそれをそのまま毎回index-accessして使う方が速い。
